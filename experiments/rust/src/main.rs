/// Example Rust code generated by `qwen3:8b`

use std::thread;
use std::time::Duration;
use std::collections::{HashMap, HashSet};
use std::fmt::{Display, Formatter};

#[derive(Debug, PartialEq)]
enum Direction {
    North,
    South,
    East,
    West,
}

impl Display for Direction {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Direction::North => write!(f, "North"),
            Direction::South => write!(f, "South"),
            Direction::East => write!(f, "East"),
            Direction::West => write!(f, "West"),
        }
    }
}

#[allow(dead_code)]
struct Position {
    x: i32,
    y: i32,
}

#[allow(dead_code)]
impl Position {
    fn new(x: i32, y: i32) -> Self {
        Position { x, y }
    }
    
    fn move_direction(&self, direction: Direction) -> Position {
        match direction {
            Direction::North => Position { x: self.x, y: self.y + 1 },
            Direction::South => Position { x: self.x, y: self.y - 1 },
            Direction::East => Position { x: self.x + 1, y: self.y },
            Direction::West => Position { x: self.x - 1, y: self.y },
        }
    }
}

fn calculate_sum(numbers: Vec<i32>) -> i32 {
    numbers.iter().sum()
}

fn main() {
    // Basic syntax
    let x = 42;
    #[allow(unused_variables)]
    let y = 3.14;
    #[allow(unused_variables)]
    let str_var = "Hello";
    let is_true = true;
    
    // Control flow
    if is_true {
        println!("Condition is true");
    } else if x > 40 {
        println!("x is greater than 40");
    } else {
        println!("Default case");
    }
    
    // Loop
    let mut count = 0;
    loop {
        count += 1;
        if count >= 5 {
            break;
        }
    }
    
    // Match
    let direction = Direction::East;
    match direction {
        Direction::North => println!("Going North :: {direction:?}"),
        Direction::South => println!("Going South :: {direction:?}"),
        Direction::East => println!("Going East :: {direction:?}"),
        Direction::West => println!("Going West :: {direction:?}"),
    }
    
    // Ownership and borrowing
    let s1 = String::from("Hello");
    let s2 = s1; // Ownership moves
    println!("{}", s2);
    
    // References
    let s = String::from("Hello");
    let len = calc_len(&s);
    println!("Length: {}", len);
    
    // Smart pointers
    let boxed = Box::new(42);
    println!("Boxed value: {}", boxed);
    
    // Trait objects
    let vec = vec![Box::new(42), Box::new(100)];
    for item in vec {
        println!("Trait object value: {}", item);
    }
    
    // Concurrency
    let handle = thread::spawn(move || {
        thread::sleep(Duration::from_secs(1));
        "Thread result"
    });
    
    println!("Main thread: {}", handle.join().unwrap());
    
    // Iterators
    let numbers = vec![1, 2, 3, 4, 5];
    let squared: Vec<_> = numbers.into_iter().map(|x| x * x).collect();
    println!("Squared numbers: {:?}", squared);
    
    // Closures
    let add_ten = |x| x + 10;
    println!("Closure result: {}", add_ten(5));
    
    // Macros
    macro_rules! greet {
        ($name:expr) => {
            println!("Hello, {}!", $name)
        };
    }
    
    greet!("Rust");
    
    // Unit tests
    assert_eq!(calculate_sum(vec![1, 2, 3]), 6);
    assert!(Direction::North != Direction::South);
    assert!(Direction::East != Direction::West);
    
    // Collections
    let mut map = HashMap::new();
    map.insert("key1", "value1");
    map.insert("key2", "value2");
    println!("Map values: {:?}", map.values());
    
    let mut set = HashSet::new();
    set.insert("item1");
    set.insert("item2");
    println!("Set contents: {:?}", set);
}

fn calc_len(s: &str) -> usize {
    s.len()
}
